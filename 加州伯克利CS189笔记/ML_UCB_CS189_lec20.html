<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-12 æ—¥ 14:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>lec 20 UNSUPERVISED LEARNING</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yiddi" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
 <link rel='stylesheet' href='css/site.css' type='text/css'/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">lec 20 UNSUPERVISED LEARNING</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org0b8e371">lec 20 UNSUPERVISED LEARNING</a></li>
<li><a href="#org7c3f685">lec 20.2 PRINCIPAL COMPONENTS ANALYSIS (PCA) (Karl Pearson, 1901)</a>
<ul>
<li><a href="#orgcfe7c3e">Eigenfaces</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="org0b8e371" class="outline-2">
<h2 id="org0b8e371">lec 20 UNSUPERVISED LEARNING</h2>
<div class="outline-text-2" id="text-org0b8e371">
<p>
[I told you last week that neural net research was popular in the 60's, but
 the 1969 book "Perceptrons" killed interest in them throughout the 70's.  They
 came back in the 80's, but interest was partly killed off a second time in the
 00's by...guess what?  By support vector machines.  SVMs work well for a lot
 of tasks, they're faster to train, and they more or less have only one
 hyperparameter, whereas neural nets take a lot of work to tune.]
[Neural nets are now in their third wave of popularity.  The single biggest
 factor in bringing them back is probably big data.  Thanks to the internet,
 we now have absolutely huge collections of images to train neural nets with,
 and researchers have discovered that neural nets often give better performance
 than competing algorithms when you have huge amounts of data to train them
 with.  In particular, convolutional neural nets are now learning better
 features than hand-tuned features.  That's a recent change.]
</p>

<p>
[One event that brought attention back to neural nets was the ImageNet Image
 Classification Challenge in 2012.]
[Show ImageNet slide (imagenet.png).]
[The winner of that competition was a neural net, and it won by a huge margin,
 about 10%.  It's called AlexNet, and it's surprisingly similarly to LeNet 5,
 in terms of how its layers are structured.  However, there are some new
 innovations that led to their prize-winning performance, besides the fact that
 the training set had 1.4 million images:  they used ReLUs, GPUs for training,
 and dropout.]
[Show AlexNet convolutional neural net diagram (alexnet.pdf).]
</p>


<pre class="example">
We have sample points, but no labels!
No classes, no y-values, nothing to predict.
Goal:  Discover structure in the data.

</pre>

<p>
Examples:
</p>
<pre class="example">
- Clustering:  partition data into groups of similar/nearby points.
- Dimensionality reduction:  data often lies near a low-dimensional subspace
  (or manifold) in feature space; matrices have low-rank approximations.
  [Whereas clustering is about grouping similar sample points, dimensionality
   reduction is more about identifying a continuous variation from sample point
   to sample point.]
- Density estimation:  fit a continuous distribution to discrete data.
  [When we use maximum likelihood estimation to fit Gaussians to sample points,
   that's density estimation, but we can also fit functions more complicated
   than Gaussians, with more local variation.]

</pre>
</div>
</div>

<div id="org7c3f685" class="outline-2">
<h2 id="org7c3f685">lec 20.2 PRINCIPAL COMPONENTS ANALYSIS (PCA) (Karl Pearson, 1901)</h2>
<div class="outline-text-2" id="text-org7c3f685">
<p>
<code>===========================</code>
Goal:  Given sample points in R^d, find k directions that capture most of the
variation.  (Dimensionality reduction.)
[Show 3D points projected to 2D (3dpca.pdf).]
[Show MNIST digits projected to 2D (pcadigits.pdf).]
</p>

<p>
Why?
</p>
<ul class="org-ul">
<li>Find a small basis for representing variations in complex things, e.g. faces.</li>
<li>Reducing # of dimensions makes some computations cheaper, e.g. regression.</li>
<li>Remove irrelevant dimensions to reduce overfitting in learning algs.
Like subset selection, but we can choose features that aren't axis-aligned,
i.e., linear combos of input features.</li>
</ul>
<p>
[Sometimes PCA is used as a preprocess before regression or classification for
 the last two reasons.]

Let X be n-by-d design matrix.  [No fictitious dimension.]
From now on, assume X is centered:  mean X_i is zero.
[As usual, we can center the data by computing the mean x-value, then
 subtracting the mean from each sample point.]
</p>

<p>
[Let's start by seeing what happens if we pick just one principal direction.]
</p>

<pre class="example">
Let w be a unit vector.                                 ~
The _orthogonal_projection_ of point x onto vector w is x = (x . w) w
               ~   x . w
If w not unit, x = ----- w
                   |w|^2

                    o x
                    |
                    |
       w            v ~
   O----------&gt;     o x

</pre>
<p>
[The idea is that we're going to pick the best direction w, then project all
 the data down onto w so we can analyze it in a one-dimensional space.
 Of course, we lose a lot of information when we project down from d dimensions
 to just one.  So, suppose we pick several directions.  Those directions span
 a subspace, and we want to project points orthogonally onto the subspace.
 This is easy <b>if</b> the directions are orthogonal to each other.]
</p>
<pre class="example">
                                            ~    k
Given orthonormal directions v_1, ..., v_k, x = sum (x . v ) v
                                                i=1       i   i
</pre>

<p>
 [The word "orthonormal" implies they're mutually orthogonal and length 1.]
[Draw picture of orthogonal projection of a point onto a plane in 3D space.]
[Usually we don't actually want the projected point in R^d;
 usually we want the coordinates x . v_i in principal components space.]
</p>

<p>
X^T X is square, symmetric, positive semidefinite, d-by-d matrix.
Let 0 &lt;= lambda_1 &lt;= lambda_2 &lt;= ... &lt;= lambda_d be its eigenvalues.   [sorted]
Let v_1, v_2, ..., v_d be corresponding orthogonal <b>unit</b> eigenvectors.
[It turns out that the principal directions will be these eigenvectors, and
 the most important ones will be the ones with the greatest eigenvalues.
 I will show you this in three different ways.]
</p>

<p>
PCA derivation 1:  Fit a Gaussian to data with maximum likelihood estimation.
Choose k Gaussian axes of greatest variance.
[Show Gaussian fitted to sample points (gaussfitpca.png).]
</p>

<pre class="example">
                                                ^     1  T
Recall that MLE estimates a covariance matrix Sigma = - X  X.  [If X centered.]
                                                      n
</pre>

<pre class="example">
PCA Alg:
- Center X.
- Optional:  Normalize X.  Units of measurement different?
  * Yes:  Normalize.
    [Bad for principal components to depend on arbitrary choice of scaling.]
  * No:  Usually don't.
    [If several features have the same unit of measurement, but some of them
     have much smaller variance, that difference is usually meaningful.]
  [Show difference outcomes between normalized and not (normalize.pdf).]
- Compute unit eigenvectors/values of X^T X.
- Optional:  choose k based on the eigenvalue sizes.
- For the best k-dimensional subspace, pick eigenvectors v_{d-k+1}, ..., v_d.
- Compute the coordinates of training/test data in principal components space.
  [When we do this projection, we have two choices:  we can un-center the input
   data before projecting it, OR we can translate the test data by the same
   vector we used to translate the training data when we centered it.]
</pre>
<p>
[Show graph of # of eigenvectors vs. variance captured (variance.pdf).
 In this example, just 3 eigenvectors capture 70% of the variance.]
[If you are using PCA as a preprocess for a supervised learning algorithm,
 there's a more effective way to choose k:  (cross-)validation.]
</p>


<p>
PCA derivation 2:  Find direction w that maximizes variance of projected data
[In other words, when we project the data down, we don't want it all to bunch
 up; we want to keep it as spread out as possible.]
[Show projection of points (project.jpg).]
</p>

<pre class="example">
                                                             T  T
      ~   ~        ~       1  n         w  2   1 |Xw|^2   1 w  X  X w
Var({ X , X , ..., X  }) = - sum (X  . ---)  = - ------ = - ---------
       1   2        n      n i=1   i   |w|     n  |w|^2   n   w^T w
                                                            \_______/
                                           _Rayleigh_quotient_ of X^T X and w
</pre>

<p>
[This fraction is a well-known construction called the Rayleigh quotient.  When
 you see it, you should smell eigenvectors nearby.  How do we maximize this?]
If w is an eigenvector v_i, Ray. quo. = lambda_i
-&gt; of all eigenvectors, v_d achieves maximum variance lambda_d / n.
One can show v_d beats every other vector too.
[Because every vector w is a linear combination of eigenvectors, and so
 its Rayleigh quotient will be a convex combination of eigenvalues.
 It's easy to prove this, but I don't want to take the time.
 For the proof, look up "Rayleigh quotient" in Wikipedia.]
[So the top eigenvector gives us the best direction.  But we typically want
 k directions.  After we've picked one direction, then we have to pick
 a direction that's orthogonal to the best direction.  But subject to that
 constraint, we again pick the direction that maximizes the variance.]
What if we constrain w to be orthogonal to v_d?  Then pick v_{d-1}.
</p>


<p>
PCA derivation 3:  Find direction w that minimizes "projection error"
[Show animation of PCA projection (PCAanimation.gif).]
[You can think of this as a sort of least-squares linear regression, with one
 important change.  Instead of measuring the error in a fixed vertical
 direction, we're measuring the error in a direction orthogonal to the
 principal component direction we choose.]
[Show linear regression vs. PCA (mylsq.png, mypca.png).]
</p>

<pre class="example">
 n  |     ~ |2    n  |     X_i . w  |2    n       2          w  2
sum |X  - X |  = sum |X  - ------- w|  = sum (|X |  - (X  . ---) )
i=1 | i    i|    i=1 | i    |w|^2   |    i=1    i       i   |w|

               = constant - n (variance from derivation 2).


</pre>

<p>
Minimizing projection error = maximizing variance.
[From this point, we carry on with the same reasoning as derivation 2.]
</p>

<p>
[Show illustration of the first two principal components of the single
 nucleotide polymorphism (SNP) matrix for the genes of various Europeans
 (europegenetics.pdf).  The input matrix has 2,541 people from these locations
 in Europe, and 309,790 SNPs.  Each SNP is binary, so think of it as 309,790
 dimensions of zero or one.  The output shows spots on the first two principal
 components where the projected people from a particular national type are
 denser than a certain threshold.  What's amazing about this is how closely the
 projected genotypes match the geography of Europe.  (From Lao et al., 2008.)]

</p>
</div>
<div id="orgcfe7c3e" class="outline-3">
<h3 id="orgcfe7c3e">Eigenfaces</h3>
<div class="outline-text-3" id="text-orgcfe7c3e">
<hr />
<p>
X contains n images of faces, d pixels each.
[If we have a 200 x 200 image of a face, we represent it as a vector of length
 40,000, the same way we represent the MNIST digit data.]
Face recognition:  Given a query face, compare it to all training faces;
                   find nearest neighbor in R^d.
[This works best if you have several training photos of each person you want to
 recognize, with different lighting and different facial expressions.]
</p>

<pre class="example">
Problem:  Each query takes Theta(nd) time.
Solution:  Run PCA on faces.  Reduce to much smaller dimension d'.
           Now nearest neighbor takes O(nd') time.
           [Possibly even less.  We'll talk about speeding up nearest-neighbor
            search at the end of the semester.  If the dimension is small
            enough, you can sometimes do better than linear time.]

</pre>

<p>
[Show images of average face and eigenfaces (facerecaverage.jpg,
 facereceigen0.jpg, facereceigen119.jpg, facereceigen.jpg).]
[Show images of a face projected onto the first 4 and 50 eigenvectors
 (eigenfaceproject.pdf).  Latter is blurry but good enough for recognition.]
For best results, equalize the intensity distributions first.
[Show image equalization (facerecequalize.jpg).]
[If each image has 40,000 pixels, and you reduce it to 40 principal components,
 then each query face requires you to read 20,000 stored coordinates instead of
 20 million pixels.]
</p>

<p>
[Eigenfaces are not perfect.  They encode both face shape <b>and</b> lighting.
 Ideally, we would have some way to factor out lighting and analyze face shape
 only, but that's harder.  Some people say that the first 3 eigenfaces are
 usually all about lighting, and you sometimes get better facial recognition by
 dropping the first 3 eigenfaces.]
[Show Blanz-Vetter face morphing video (morphmod.mpg).]
[Blanz and Vetter use PCA in a more sophisticated way for 3D face modeling.
 They take 3D scans of people's faces and find correspondences between peoples'
 faces and an idealized model.  For instance, they identify the tip of your
 nose, the corners of your mouth, and other facial features, which is something
 the original eigenface work did not do.  Instead of feeding an array of pixels
 into PCA, they feed the 3D locations of various points on your face into PCA.
 This works more reliably.]
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2017-06-22 äº”</p>
<p class="author">Author: yiddi</p>
<p class="date">Created: 2018-08-12 æ—¥ 14:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
