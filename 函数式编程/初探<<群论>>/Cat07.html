<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-12 日 05:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>群论笔记 07</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yiddishkop" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
 <link rel='stylesheet' href='css/site.css' type='text/css'/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">群论笔记 07</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#cat-7.1-functoriality-bifunctors">Cat 7.1 Functoriality, bifunctors</a>
<ul>
<li><a href="#org2896bf4">composition of functors</a></li>
<li><a href="#product-functor">Product functor</a>
<ul>
<li><a href="#define-a-functor-of-2-categories-by-extending-existing-functor">Define a functor of 2 categories by extending existing functor</a></li>
<li><a href="#bifunctor">Bifunctor</a></li>
<li><a href="#how-to-define-a-bifunctor">How to define a Bifunctor</a></li>
</ul>
</li>
<li><a href="#sum-functor">Sum functor</a></li>
<li><a href="#summary-for-c-c---c">summary for <code>C × C -&gt; C</code></a></li>
<li><a href="#monoidal-category-1">Monoidal Category 1</a></li>
<li><a href="#some-concept-shoud-say-again">Some concept shoud say again:</a></li>
</ul>
</li>
<li><a href="#orgf9df983">Cat 7.2 Monoidal Categories,Functoriality of ADTs, Profunctors</a>
<ul>
<li><a href="#orgd9ecdfa">Monoidal category 2</a>
<ul>
<li><a href="#go-back-to-haskell">go back to haskell</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="org241a229" class="outline-2">
<h2 id="cat-7.1-functoriality-bifunctors"><a id="org241a229"></a>Cat 7.1 Functoriality, bifunctors</h2>
<div class="outline-text-2" id="text-cat-7.1-functoriality-bifunctors">
<p>
[lecture review]
</p>
<ul class="org-ul">
<li>Functor is mappings between category;</li>
<li>Endofunctor is mapping with in a category.</li>
<li>Huge of functions putting together</li>
<li>one major function map objects</li>
<li>preserve the structure of category</li>
<li>mapping between hom-sets</li>
<li>if no connection will not maping; if has will not be destroyed</li>
<li>preserve the composition and identity.</li>
<li><b>object to object</b> &#x2014; type constructor F, like List/Seq/Option</li>
<li id="<b>hom-set to hom-set</b> &#x2014; fmap">(a-&gt;b)-&gt;(Fa-&gt;Fb), F is type constructor.</li>
<li>ordinaty functor = type constructor + fmap</li>
<li>everything we defined for function is suit for functor, like injective and surjective</li>
<li>List is function, function is list</li>
<li>function is exponential datatype</li>
</ul>
</div>

<div id="org2896bf4" class="outline-3">
<h3 id="org2896bf4">composition of functors</h3>
<div class="outline-text-3" id="text-org2896bf4">
<p>
now functors can <b>composable</b>, and also <b>identity</b>, and also
<b>assoiative</b>.
</p>

<p>
titter :)
</p>

<p>
functors can be a category!
</p>

<p>
In <b>functor category*(or called category of functors) *functor</b> are
<b>morphisms</b>.
</p>

<p>
what is functor? he is mapping of categories. what is function? he is
mapping of objects.
</p>

<p>
so, <b>category</b> is the <b>object</b> of <b>functor category</b>, so category in
functor category has another name <b>cat</b>.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">tail</span> <span class="org-haskell-operator">::</span> [a] <span class="org-haskell-operator">-&gt;</span> [a] <span class="org-haskell-operator">//</span>not safe for empty list
</pre>
</div>

<blockquote>
<p>
[a] is like List[A] in scala
</p>
</blockquote>

<p>
we now learned the functor category, so we can define a <code>safeTail</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-definition">safeTail</span> <span class="org-haskell-operator">::</span> [a]<span class="org-haskell-operator">-&gt;</span><span class="org-haskell-type">Maybe</span>[a]
<span class="org-haskell-definition">safeTail</span> <span class="org-haskell-constructor">[]</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span>
<span class="org-haskell-definition">safeTail</span> (x<span class="org-haskell-constructor">:</span> xs) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Just</span> xs
</pre>
</div>

<blockquote>
<p>
note that: 1. [a] is functor; Maybe[a] is functor; 2. safeTail is a
mapping of functors; 3. like functor is a mapping of categories,
safeTail is a functor of functor categories
</p>
</blockquote>

<p>
seriously, :| remember <code>fmap</code>? <code>fmap</code> is a mapping of functions; <code>safeTail</code> is a
mapping of functors;
</p>

<p>
we may should try using fmap
</p>

<p>
<b>fmap will always go inside of container(functor), and apply the operation on
the inside things, and again put it back into the container.</b>
</p>

<p>
seriously, :|
</p>

<ol class="org-ol">
<li>now I find that, haskell has a syntax type as lisp: all operator and function
are prefix, damn it.</li>

<li>because function is list, and list is function. so in scala, we can apply
<code>fmap</code> twin <code>map</code> to <code>Collections</code>, although the signiture of fmap is a
mapping from function to function.</li>
</ol>

<p>
=haskell square on the Maybe
</p>
<pre class="example">
:: Maybe[Int] sq
:: Int -&gt; Int fmap( fmap sq ) mis // same with (fmap . fmap)
sq mis // remeber that,
(a-&gt;b)-&gt;(Fa-Fb) =&gt; ((a-&gt;b)-&gt;Fa) -&gt; Fb
</pre>

<p>
note that
</p>

<ol class="org-ol">
<li><code>fmap sq</code> is applying fmap to a function, you get a function &gt;</li>
<li><code>fmap( famp sq )</code> is applying fmap to the function return from <b>step(1)</b>,
again get a function</li>
<li>funcion from <b>step(2)</b>, takes <code>mis</code> as parameter, operate on inside value of
<code>mis</code> getting another value, then put it back into the container.</li>
</ol>

<p>
this is how you compose the functors in haskell
</p>

<p>
we mentioned previous lecture that, almost all the type constructor in
haskell will automatically be a functor, because regular data structure
in haskell are algebraic data types, all these algebraic data types are
<b>automatically functorial</b>. And algebraic data types have some
<b>operations</b> like product(-type), sum(-type), exponential(-type).
</p>

<blockquote>
<p>
so in algebraic datatypes' eyes, the <code>Either/Option/Try/Future</code> are
same as <code>+</code> in algebraic, they are both operation so in algebraic
datatypes' eyes, the <code>collections</code> are same as <code>*</code> in algebraic, they
are both operation so in algebraic datatypes' eyes, the <code>functions</code>
are same as <code>^</code> in algebraic, they are both operation
</p>
</blockquote>

<p>
when you use these "operaion" on algebraic datatypes, you automatically
get a functor, and a 1-to-1 relationship will build up:
</p>
</div>
</div>

<div id="org3c4f077" class="outline-3">
<h3 id="product-functor"><a id="org3c4f077"></a>Product functor</h3>
<div class="outline-text-3" id="text-product-functor">
<p>
<code>(a,b)</code> is a product-type, when can rewrite in another fomr <code>(,) a b</code>,
and when we <b>fix a</b> ,is it a type constructor of b. Something like
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">type</span> <span class="org-haskell-type">X</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">(,)</span> a
<span class="org-haskell-constructor">X</span> b
</pre>
</div>

<p>
<code>X</code> now is a type constructor of b, a functor on b, a contrainer of b.
Now we can apply function to b, by fmap, we just illustrate it:
</p>

<p>
of couse it could do ,and the related scala code is like: a reference to <a href="https://typelevel.org/blog/2016/08/21/hkts-moving-forward.html">type
constructor used in scala's function</a>
</p>
</div>

<div id="org6b772e5" class="outline-4">
<h4 id="define-a-functor-of-2-categories-by-extending-existing-functor"><a id="org6b772e5"></a>Define a functor of 2 categories by extending existing functor</h4>
<div class="outline-text-4" id="text-define-a-functor-of-2-categories-by-extending-existing-functor">
<p>
Instead of definging a functor of 2 arguments &#x2014; these 2 arguments are
types(objects) of ONE category, can we define a functor of TWO
categories: one type(object) from one category, the other (type)obj from
another category.
</p>

<p>
Further more, we can define a product of two categories, then functor
from the product of categories would be a functor of two arguments, of
course.
</p>

<p>
But product of categories will be something too complex, even product in
ONE set category would use some universal construction.
</p>

<p>
NO~~~ product of 2 categories is really easy to define, easiser than the
product in set category, at least for SMALL category &#x2014; which is
objects in a category from sets.
</p>

<blockquote>
<p>
small category A category C is called small if both ob(C) and hom(C)
are actually sets and not proper classes, and large otherwise. A
locally small category is a category such that for all objects a and
b, the hom-class hom(a, b) is a set, called a homset. simply speeking,
small category has two set: One set of objects, One set of arrows &#x2014;
hom-set.
</p>
</blockquote>

<ol class="org-ol">
<li><p>
object of product category
</p>

<p>
So we define a product category, and all objects inside are pair(or
called Tuple), and is the product of the set of objects in two
categories. It's easy, aren't they, because in small category,
objects are in a set, so you have two category means you have two
sets of objects, set can do Cartesian Product. ===&gt; The product
category has object as a pair in it.
</p></li>

<li><p>
arrow of product category
</p>

<p>
But, how to do with morphisms(arrows). This is same thing you know,
becasue the small category has all arrows in a hom-set, and hom-set
is set, it can also do Cartesian Product. ===&gt; The product category
has arrow as a pair in it.
</p></li>

<li><p>
proving composition
</p>

<p>
So we have new category( not prove identity, composition and identity
yet), and we have objects(a pair) and arrows(a pair), Now if we can
prove the composition identity associativity, then we truely have a
new category, a product category
</p></li>

<li><p>
proving identity
</p>

<p>
we also have identity: <code>(id, di) = id</code>
</p></li>

<li><p>
proving associative
</p>

<p>
easy, skipped.
</p></li>
</ol>

<p>
we now have a product category, then we can move forward to bifunctor
</p>
</div>
</div>

<div id="org9c306ac" class="outline-4">
<h4 id="bifunctor"><a id="org9c306ac"></a>Bifunctor</h4>
<div class="outline-text-4" id="text-bifunctor">
<pre class="example">
C × D ---&gt; E
</pre>

<p>
Bifunctor is just a functor for the product category, a mapping between
a product category and a category. But as you know, we want a product
category in Haskell, because the category is ONE category will object
are type and arrow are functions, so product category is:
</p>

<pre class="example">
C × C ---&gt; C
</pre>

<p>
<code>C</code> is the Haskell, so what we are doing for product category is:
</p>

<pre class="example">
Haskell × Haskell ---&gt; Haskell 
</pre>

<p>
yes, we get it~:
</p>

<div class="org-src-container">
<pre class="src src-haskell">a <span class="org-haskell-definition">&#215;</span> b <span class="org-haskell-operator">---&gt;</span> (a,b)
</pre>
</div>
</div>
</div>

<div id="org58ee437" class="outline-4">
<h4 id="how-to-define-a-bifunctor"><a id="org58ee437"></a>How to define a Bifunctor</h4>
<div class="outline-text-4" id="text-how-to-define-a-bifunctor">
<p>
In this scenario ,we Lift two functions at same time to combine them to
a pair of function, which is an arrow in new product categoy, so we can
say:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">class</span> <span class="org-haskell-type">Bifunctor</span> f <span class="org-haskell-keyword">where</span>
  bimap <span class="org-haskell-operator">::</span> (a<span class="org-haskell-operator">-&gt;</span>a') <span class="org-haskell-operator">-&gt;</span> (b<span class="org-haskell-operator">-&gt;</span>b') <span class="org-haskell-operator">-&gt;</span> (f a b <span class="org-haskell-operator">-&gt;</span> f a' b')
</pre>
</div>

<p>
<code>f</code> is two type variable functor(or constructor), like something in
scala: <code>Map[_,_]</code> or <code>Function[_,_]</code>.So, product is a bifunctor.
</p>

<p>
Seriously :| By now I find that, <b>Functor is what we say the type
constructor with a map(which do operte unboxing and boxing) inside.</b>
</p>

<p>
Nothing else.
</p>
</div>
</div>
</div>

<div id="org5be93f5" class="outline-3">
<h3 id="sum-functor"><a id="org5be93f5"></a>Sum functor</h3>
<div class="outline-text-3" id="text-sum-functor">
<p>
Then you may think, we have <b>product functor</b> now, what about <b>sum
functor</b>?
</p>

<p>
No worries, we can use the same principle of BiFunctor, apply to sum
functor.
</p>

<p>
<code>Either a b</code> is a <b>sum-type</b>, but you should notice that we describe it
by a <b>BiFunctor manner</b>.
</p>

<p>
<code>Either a b</code> takes a pair of types, OK pair of types is a product
category, like we have find above. Instead of every object and arrow is
<b>tuple pair</b> &#x2014;
</p>

<p>
( * for object in product category: <code>(,) a b</code> * for arrow in product
category: <code>(,) f g</code>
</p>

<p>
),
</p>

<p>
they should <b>eigher pair</b> &#x2014;
</p>

<p>
( * for object in "eigther" category: <code>eigher a b</code> * for arrow in
"eigther" category: <code>eigher f g</code>
</p>

<p>
),
</p>

<p>
in this sum-type scenario.
</p>

<p>
the ONLY difference is <code>fmap</code>, you must use a case clause to match one
type or the other one.
</p>
</div>
</div>

<div id="orgac722c7" class="outline-3">
<h3 id="summary-for-c-c---c"><a id="orgac722c7"></a>summary for <code>C × C -&gt; C</code></h3>
<div class="outline-text-3" id="text-summary-for-c-c---c">
<p>
here we have two kinds of functor: product-functor and sum-functor, they
can be both decribed by <code>C×C-&gt;C</code> &#x2014; BiFunctor form.
</p>

<p>
Actually in any category, if you have products defined for all pair of
objects, like two: product-functor and sum-functor above, we have
another name for that category: <b>Cartesian Category</b>
</p>

<blockquote>
<p>
C × C -&gt; C , BiFunctor , Cartesian Category.
</p>
</blockquote>

<p>
And the same is true about the <b>coproduct</b>, <b>coproduct is also a
BiFunctor</b>, long ago from now we defined coproduct just by the objects,
but now we should define the coproduct also for morphism(arrow), just
like what we do for product-functor above.
</p>

<p>
So, what we want to prove, I want to show that this is bifunctor I have
to show that I can lift this pair <code>(f,g)</code> to something that there is a
unique morphism between <code>a × b</code> and <code>a' × b'</code>. But how can I do this, if
we compose f and p, compose q and g, we will find something familiar.
</p>

<p>
yes, <code>a × b</code> become one candidate of <code>a' × b'</code> with two projections <code>a'</code>
and <code>b'</code>. So, there must be a unique morphism between the <code>a × b</code> and
<code>a' × b'</code>, we call this morphism <code>f × g</code> and this is "but now we should
define the <b>coproduct also for morphism(arrow)</b>" &#x2014; the coproduct
lifting.
</p>
</div>
</div>

<div id="orgd367ed5" class="outline-3">
<h3 id="monoidal-category-1"><a id="orgd367ed5"></a>Monoidal Category 1</h3>
<div class="outline-text-3" id="text-monoidal-category-1">
<p>
That is <b>categorical product</b>, not just only a <b>pair</b>, that's a
cartesian category, it's a bifunctor, and if we have a coproduct in a
category, we will have some co-Cartesian category. Then the coproduct is
a bifunctor as well. So we have a category that has a bifunctor more
general that just product or coproduct, maybe there are other
bifunctors. So this kind of category have a bifunctor are called
<b>monoidal category</b> , * <b>bifunctor</b> is like a <b>binary operater</b>. * for
<b>unit</b> we will prove that next lecture.
</p>

<p>
titter :) , monoid again, you know, unit and associative
</p>
</div>
</div>

<div id="org55e48bc" class="outline-3">
<h3 id="some-concept-shoud-say-again"><a id="org55e48bc"></a>Some concept shoud say again:</h3>
<div class="outline-text-3" id="text-some-concept-shoud-say-again">
<ul class="org-ul">
<li>Product category is <code>C * D -&gt; E</code></li>
<li>but Product category in Haskell is just <code>C * C -&gt; C</code>, &#x2014; Haskell is
ONE Category</li>
<li>So this is the same(?) thing with two arguments type constructor</li>
<li>Cartesian Category is another name of Product category</li>
<li>Monoidal category is that we have a bifunctor(simply speeking, two
arguments type constructor) like Map[/,/] on this Cartesian category.</li>
<li>bifunctor of Monidal category is that binary operator of Monoid</li>
</ul>
</div>
</div>
</div>

<div id="orgf9df983" class="outline-2">
<h2 id="orgf9df983">Cat 7.2 Monoidal Categories,Functoriality of ADTs, Profunctors</h2>
<div class="outline-text-2" id="text-orgf9df983">
</div>
<div id="orgd9ecdfa" class="outline-3">
<h3 id="orgd9ecdfa">Monoidal category 2</h3>
<div class="outline-text-3" id="text-orgd9ecdfa">
<p>
we'll not introduce all things about monoidal category, it's too
abstract.
</p>

<p>
In the monoidal category we would like to define things like what does
it mean to multiply two objects.
</p>

<p>
product category is something like a way of multiplying objects, you
have object a and object b, you multiply them and get the product.Now we
have one part of a monoid &#x2014; binary operation &#x2014; bifuncotr.
</p>

<ul class="org-ul">
<li>monoid is for set category

<ul class="org-ul">
<li>binary operation is for elements of object set, or elements of
hom-set.</li>
<li>for production, <b>unit</b> is singleton set <code>()</code>, terminal object up to
isomorphism.</li>
</ul></li>

<li>monoidal category is product category wih operater bifunctor.

<ul class="org-ul">
<li>you can prove <b>unit</b> from graphic below.</li>
<li>you also can find <b>bifunctor</b>.</li>
</ul></li>
</ul>

<p>
it means like something <code>F[A,Unit] = F[A]</code> in scala.
</p>

<p>
I can do the same thing for coproduct, <b>unit would be the initial
object</b>
</p>

<p>
What's the good name for this product that could be a coproduct or could
be a bifunctor, it's called <b>tensor product</b>, So monoidal category has a
<b>tensor product</b>. tesor product has a unit.
</p>
</div>

<div id="org7d63bfc" class="outline-4">
<h4 id="go-back-to-haskell"><a id="org7d63bfc"></a>go back to haskell</h4>
<div class="outline-text-4" id="text-go-back-to-haskell">
<p>
Haskell is really a monoidal category, because we had product something
in product and co-product. I start all this discussion because I said
that ADT are functorial. So far we see that the <b>product</b> is functorial
and coproduct is functorial, product type and sum type are functorial.
</p>

<p>
stop noting at 12:13
</p>

<ol class="org-ol">
<li>constant type diff from type constructor ,deos not depend on type,
but they depend on values ok?</li>
<li>constant functor is mapping any type to a black hole.</li>
</ol>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Const</span> c a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Const</span> c

<span class="org-haskell-keyword">instance</span> <span class="org-haskell-type">Functor</span>(<span class="org-haskell-type">Const</span> c)<span class="org-haskell-operator">//</span> const c is partially appplied to const c a, its a <span class="org-haskell-keyword">type</span> constructor for a, a functor like <span class="org-string">'f'</span> before<span class="org-haskell-operator">.</span>
  <span class="org-comment-delimiter">-- </span><span class="org-comment">fmap:: (a-&gt;b)-&gt; Const c a -&gt; Const c b</span>
<span class="org-haskell-operator">???</span>  fmap f (<span class="org-haskell-constructor">Const</span> c) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Const</span> c

<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Identity</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Identity</span> a
  fmap f (identity a) <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Identity</span> (f a)
</pre>
</div>

<p>
for a container, Const c is very special, it is alwasy empty.
</p>

<p>
now we have functor, and identity, we can do composing.
</p>

<p>
if a type is ADT, it's must be a functor
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Maybe</span> a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Nothing</span> <span class="org-haskell-operator">|</span> <span class="org-haskell-constructor">Just</span> a
<span class="org-haskell-constructor">Either</span> <span class="org-haskell-constructor">()</span> (<span class="org-haskell-constructor">Identity</span> a)
<span class="org-haskell-operator">//</span> <span class="org-haskell-constructor">()</span> can be <span class="org-haskell-constructor">Cons</span> <span class="org-haskell-constructor">()</span> a
</pre>
</div>

<p>
every ADT can transform to a functor using this metohd.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-pragma">{-# LANGUAGE DeriveFunctor #-}</span>
<span class="org-haskell-keyword">data</span> <span class="org-haskell-type">Maybe</span> <span class="org-haskell-operator">=</span> <span class="org-haskell-operator">......</span>
     <span class="org-haskell-keyword">deriving</span> <span class="org-haskell-constructor">Functor</span>
</pre>
</div>

<p>
there is only one fmap(a theory can prove that, not refer deep here)
</p>

<p>
<code>(-&gt;) a b = a -&gt; b</code>
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span class="org-haskell-keyword">newtype</span> <span class="org-haskell-type">Reader</span> c a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Reader</span> ( c<span class="org-haskell-operator">-&gt;</span> a)
<span class="org-haskell-definition">fmap</span> <span class="org-haskell-operator">=</span> (<span class="org-haskell-operator">*</span>) <span class="org-haskell-operator">//</span> remember that<span class="org-haskell-operator">?</span>
<span class="org-haskell-constructor">Op</span> c a <span class="org-haskell-operator">=</span> <span class="org-haskell-constructor">Op</span> (a<span class="org-haskell-operator">-&gt;</span>c)
fmap<span class="org-haskell-operator">::</span>(a<span class="org-haskell-operator">-&gt;</span>b) <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Op</span> c a <span class="org-haskell-operator">-&gt;</span> <span class="org-haskell-type">Op</span> c b
                 <span class="org-haskell-operator">//</span>a<span class="org-haskell-operator">-&gt;</span>c   <span class="org-haskell-operator">//</span>b<span class="org-haskell-operator">-&gt;</span>c
</pre>
</div>

<p>
Is this a bifunctor above?
</p>

<ul class="org-ul">
<li>a -&gt; b</li>
<li>a -&gt; c</li>
<li>b -&gt; c // we can not get this function ???</li>
</ul>

<p>
If we have 'b-&gt;a' that's good, so a-&gt;b is bad, can we reverse?
</p>

<p>
C\^Op -&gt; D a -&gt; b a &lt;-C- b
</p>

<p>
in haskell, it's a opposite haskell category to haskell This kind of
functor has a name called <b>Contravariant</b> functor.
</p>

<p>
class Contravariant f where contrmap:: (b-&gt;a) -&gt; (fa -&gt; fb)
</p>

<p>
Contra functor is not a container, more like a Contra-conatiner
</p>

<p>
when refer to a <b>bifunctor</b>:
</p>

<p>
(-&gt;) a b C\^op X C -&gt; C // you take a pair morphism, but 1st is flip to
another side
</p>

<p>
This is called <b>Profunctor</b>,
</p>

<p>
class Profunctor p where dimap :: (a' -&gt; a) -&gt; (b -&gt; b') -&gt; p a b -&gt; p
a' b' f g (a-&gt;b) (a' -&gt; b') h // by f,g,h ,how to get a'-&gt;b' g * h * f
</p>

<p>
lmap ? rmap ?
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
